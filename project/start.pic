

using "builtin/syncio";
using "builtin/asyncio";
using "builtin/array";
using "builtin/sync";


using "math";
using "dummy/dummy";
using "utils";
// using "math/random" as rand;
// using "builtin/syncio";


// TODO:
// // refactor all go code. c is good
// // fix that packages & import things

// // write base c modules
// // write tire-0 modules


// base c modules: import like "builtin/os", "builtin/io"..
// os // expose all syscalls & os level extra info
// io // fileio, netio, stdinio
// atomic // for atomic types & ops 
// sync // synchronization primitives e.g, mutex, locks
// crypto // basic hash functions etc.. optional
// array // basic array ops, len(), bound check etc..
// string // basic string ops, len(), modifications , mutable vs immutable, need to see


// tier-0: import like "os", "io"..
// os // wrap "builtin/os" & provide interface for io 
//     os/syscalls
//     os/io 



class Next: math.Nanu {
    fn Next() {

    }
    fn evaru(): string {
        return "nene";
    }
}

class Node {
    say y: start.Next = new start.Next();
    fn Node() {
        
    }

    fn len(s: string): int {
        // say ad: math.Adder = new math.Adder();
        // say c: dummy.Dummy = new dummy.Dummy();

        // ad.u.giveOne();

        // return ad.add(10 , 20) + c.giveTwo();
        return 0;

    }
}

class Worker {
    say x: start.Node;

    say counter: atomic int;
    say _thread_id: atomic int;

    fn Worker(count: int) {
        syncio.printf(" value of this.counter: %p [class = %p]\n", this.counter, this);
        syncio.printf(" value of _thread_id: %p [class = %p]\n", this._thread_id, this);
        sync.atomic_store(this.counter, count);
        sync.atomic_store(this._thread_id, 0);

        this.x = new start.Node();
    } 

    fn raiseErr() {
        say y: int = 10 / 0;
    }

    fn raiseBeforeErr() {
        // this.raiseErr();
        say x: start.Node = new start.Node();
        say l:int = x.len("something");

    }

    fn do() {

        this.raiseBeforeErr();
        sync.atomic_add(this._thread_id, 1);
        say id: int = sync.atomic_load(this._thread_id);

        say buff_size: int = 256;
        say buf: []int8 = array.create(int8, buff_size);

        syncio.printf(" value of array = %p \n", buf);
        say fp: string = syncio.fopen("/workspaces/x-language/project/temp.txt", "r+");
        say seek: int = 0;

        foreach i in 1..10000 {
            say n: int = syncio.fread(fp, buf, buff_size, seek);
            if(i==9999){
                asyncio.printf("=========[%d]=> done - %d buf = %p\n", id, i, buf);
                return;
            }
            // seek = seek + buff_size;
            // asyncio.printf("%.*s\n", n, buf);

            // if(n<buff_size) {
            //     return;
            // }else {}
        }
    }
}

fn start() {
    say w1: start.Worker = new start.Worker(1000);


    say x: math.Nanu = new start.Next();

    syncio.printf(": %s \n", x.evaru());

    // w1.do();
    // foreach i in 1..100 {
    //    thread(w1.do);
    // }
}